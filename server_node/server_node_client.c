/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "server_node.h"
#include <unistd.h>
#include <arpa/inet.h>
#include <stdio.h>


// checksum function
// generate checksum character from data
// to use, run this function against the data, if checksum is nonzero it fails
unsigned char checksum(char *ptr, int size) {
    char * iterate; // first copy the pointer to not change the original
    unsigned char checksum = 0;

    for (iterate = ptr; size-- > 0; iterate++) {
        checksum ^= *iterate;
    }
    return checksum;
}

// Main
int main (int argc, char *argv[])
{
	char *host;

	if (argc < 4) {
		printf ("%s <server_ip> <server_port> [option]\n", argv[0]);
		return 1;
	}
	host = argv[1];
	int server_port = atoi(argv[2]);


	//Create RPC client for the CENTRAL server
	CLIENT *clnt;
	if(init_rpc_client(&clnt, host, server_port) != 0) {
		printf("Error rpc init\n");
		return 1;
	}

	// Control structure for client options BELOW
	char* option = argv[3];

	// List all files and their locations
	if(strcmp(option, "list_all") == 0)
	{
		int fileno = 0;
		while(1) {
			file_info* contents;
			contents = list_hosts_num_1(fileno, clnt);
			if(contents == NULL) {
				printf("Failed to make RPC call.  Central server offline\n");
				clnt_destroy(clnt);
				return 1;
			}

			if(contents->name[0] == '\0') {  // End condition, no more files
				if(fileno == 0) {
					printf("No files tracked by the main server\n");
				}
				break;
			}
			printf("File %s has hosts: ", contents->name);
			for(int i = 0; i < MAXHOST; i++) {
				if(contents->hosts[i].port == -1) {
					break;
				}
				printf("%s : %d, ", contents->hosts[i].ip, contents->hosts[i].port);
			}
			printf("\n");
			fileno++;
		}
	}

	// List the servers with an input file name
	else if(strcmp(option, "list") == 0)
	{
		if(argc < 5) {
			printf("Option needs additional argument: [filename]\n");
			clnt_destroy(clnt);
			return 1;
		}
		file_info* contents;
		contents = list_hosts_str_1(argv[4], clnt);
		if(contents == NULL) {
			printf("Failed to make RPC call.  Central server offline\n");
			clnt_destroy(clnt);
			return 1;
		}

		if(contents->name[0] == '\0') {  // File not found
			printf("File not found on currently joined servers\n");
		}
		else {
			printf("File %s has hosts: ", contents->name);
			for(int i = 0; i < MAXHOST; i++) {
				if(contents->hosts[i].port == -1) {
					break;
				}
				printf("%s : %d, ", contents->hosts[i].ip, contents->hosts[i].port);
			}
			printf("\n");
		}
	}

	// Check for updates on HARDCODED servers
	// Just for debugging currently, maybe something else later
	else if(strcmp(option, "check_update") == 0)
	{
		// Hardcoded for now to check 2 set servers for updates
		void* result;
		result = check_client_update_1("127.0.0.1", 8001, clnt);
		if(result == NULL) {
			printf("Failed to make RPC call.\n");
			clnt_destroy(clnt);
			return 1;
		}

		result = check_client_update_1("127.0.0.1", 8002, clnt);
		if(result == NULL) {
			printf("Failed to make RPC call\n");
			clnt_destroy(clnt);
			return 1;
		}
	}

	// Download a file from one of the centrally tracked servers
	else if(strcmp(option, "download") == 0)
	{
		// call find_host
		// use return result to make another call to the host with the file
		// something like:
		if(argc < 5) {
			printf("Option needs additional argument: [filename]\n");
			clnt_destroy(clnt);
			return 1;
		}

		host_info *host = find_host_1(argv[4], clnt);
		if(host == NULL) {
			printf("Failed to make RPC call.  Central server offline\n");
			return 1;
		}
		if(host == NULL || host->port == -1) {
			printf("Failed to find host for %s\n", argv[4]);
			return 1;
		}

		// DOWNLOAD AND PRINT FILE CONTENTS

		CLIENT* peer_clnt;
		if(init_rpc_client(&peer_clnt, host->ip, host->port) == 1) {
			printf("Failed to create RPC client\n");
			return 1;
		}

		// Prep read loop
		printf("requesting file %s\n", argv[4]);
		int idx = 0;
		int bytes_read = MAXSIZE;

		// Args for the download RPC call, filename stays consistent
		download_1_argument args;
		args.file_name = argv[4];

		// filepath of thing being downloaded
		char shr_filepath[MAXPATHLEN + 4];
		strcpy(shr_filepath, "shr/");
		strcpy(&shr_filepath[4], argv[4]);

		// Read loop
		while(bytes_read == MAXSIZE) 
		{
			args.idx = idx;
			void* res = make_rpc_call(peer_clnt, download, xdr_download_1_argument, &args, xdr_file_packet);
			if(res == NULL) {
				printf("Connection to peer server failed\n");
				return 1;
			}

			// Dechiper contents
			file_packet *contents = ((file_packet*) res);
			bytes_read = contents->size;

			// issue reading the file on the host's end
			if(bytes_read < 0) {
				printf("Remote host failure: %s\n", contents->bytes);
				return 1;
			}

			char buf[MAXSIZE];
			memcpy(buf, contents->bytes, contents->size);
			char checksum_res = checksum(buf + 1, contents->size - 1);
			if (checksum_res != contents->bytes[0]) {
				printf("Download checksum failed.  Expected %c, got %c\n", contents->bytes[0], checksum_res);
				remove(shr_filepath);
				return 1;
			}

			// Append to file (this will not work well on existing files)
			FILE *dFile = fopen(shr_filepath, "ab");
			if(dFile == NULL) {
				perror("fopen");
				return 1;
			}
			if(fwrite(contents->bytes + 1, 1, contents->size - 1, dFile) < 0) {
				perror("fwrite");
				return 1;
			}
			fclose(dFile);
			// printf("Wrote %s to %s\n", contents->bytes, args.file_name); 
			idx++;
		}
		printf("%s successfully downloaded to %s\n", argv[4], shr_filepath);
	}

	// More options?

	else {
		printf("Option not recognized.  Valid options are:\n  list [filename]\n  list_all\n  download [filename]\n");
	}

	clnt_destroy(clnt);
	return 0;
}
