/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "server_node.h"
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif

static file_info *
_list_hosts_str_1 (char * *argp, struct svc_req *rqstp)
{
	return (list_hosts_str_1_svc(*argp, rqstp));
}

static file_info *
_list_hosts_num_1 (int  *argp, struct svc_req *rqstp)
{
	return (list_hosts_num_1_svc(*argp, rqstp));
}

static void *
_check_client_update_1 (check_client_update_1_argument *argp, struct svc_req *rqstp)
{
	return (check_client_update_1_svc(argp->ip, argp->port, rqstp));
}

static host_info *
_find_host_1 (char * *argp, struct svc_req *rqstp)
{
	return (find_host_1_svc(*argp, rqstp));
}

static bool_t *
_ping_1 (void  *argp, struct svc_req *rqstp)
{
	return (ping_1_svc(rqstp));
}

static void
server_node_prog_1(struct svc_req *rqstp, register SVCXPRT *transp)
{
	union {
		char *list_hosts_str_1_arg;
		int list_hosts_num_1_arg;
		check_client_update_1_argument check_client_update_1_arg;
		char *find_host_1_arg;
	} argument;
	char *result;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct svc_req *);

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
		return;

	case list_hosts_str:
		_xdr_argument = (xdrproc_t) xdr_wrapstring;
		_xdr_result = (xdrproc_t) xdr_file_info;
		local = (char *(*)(char *, struct svc_req *)) _list_hosts_str_1;
		break;

	case list_hosts_num:
		_xdr_argument = (xdrproc_t) xdr_int;
		_xdr_result = (xdrproc_t) xdr_file_info;
		local = (char *(*)(char *, struct svc_req *)) _list_hosts_num_1;
		break;

	case check_client_update:
		_xdr_argument = (xdrproc_t) xdr_check_client_update_1_argument;
		_xdr_result = (xdrproc_t) xdr_void;
		local = (char *(*)(char *, struct svc_req *)) _check_client_update_1;
		break;

	case find_host:
		_xdr_argument = (xdrproc_t) xdr_wrapstring;
		_xdr_result = (xdrproc_t) xdr_host_info;
		local = (char *(*)(char *, struct svc_req *)) _find_host_1;
		break;

	case Ping:
		_xdr_argument = (xdrproc_t) xdr_void;
		_xdr_result = (xdrproc_t) xdr_bool;
		local = (char *(*)(char *, struct svc_req *)) _ping_1;
		break;

	default:
		svcerr_noproc (transp);
		return;
	}
	memset ((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		svcerr_decode (transp);
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
		svcerr_systemerr (transp);
	}
	if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		fprintf (stderr, "%s", "unable to free arguments");
		exit (1);
	}
	return;
}

// Read in info and ping the servers in serverlist.txt
// Only called in child process, meant to not return
// Process ends when the main server goes offline
void pinger(int port) 
{
	// Read in server network info
	FILE* servers = fopen("../serverlist.txt", "r");
	if(servers == NULL) {
		perror("fopen");
		return;
	}

	char buf[1024];
	if(fread(buf, 1, 1024, servers) < 0) {
		perror("fread");
		fclose(servers);
		return;
	}
	fclose(servers);

	// Get num_servers (first item)
	char *temp = strtok(buf, "\n");
	int num_servers = atoi(temp);
	host_info hosts[num_servers];

	// Parse each server in server_list
	for(int i = 0; i < num_servers; i++) {
		temp = strtok(NULL, ",");
		strcpy(hosts[i].ip, temp);
		temp = strtok(NULL, "\n");
		hosts[i].port = atoi(temp);
	}

	// Create host RPC client
	CLIENT* clnt;
	if(init_rpc_client(&clnt, "127.0.0.1", port) == 1) {
		printf("Error creating central RPC client");
		return;
	}

	// Pinging Loop
	int idx = 0;
	while(1)
	{
		sleep(2);  // A little delay between pings
		// Ping main
		void *res = make_rpc_call(clnt, Ping, xdr_void, NULL, xdr_bool);
		if(res == NULL || *((int*) res) != 1) {
			break;
		}

		CLIENT* peer_clnt;
		if(init_rpc_client(&peer_clnt, hosts[idx].ip, hosts[idx].port) == 0) {
            // Call check_update on a client

            check_client_update_1_argument args;
            args.ip = hosts[idx].ip;
            args.port = hosts[idx].port;

            // Check a client for an update
            // This will propogate updates on the main server
            make_rpc_call(clnt, check_client_update, 
                xdr_check_client_update_1_argument, &args, xdr_void);
			clnt_destroy(peer_clnt);
		}
		else {
			printf("Failed to create RPC client for %s : %d\n", hosts[idx].ip, hosts[idx].port);
		}
		idx = (idx + 1) % num_servers;
	}
	printf("Main server offline\n");
	clnt_destroy(clnt);
	return;
}


// Main
int main (int argc, char **argv)
{
	if(argc < 2) {
		printf("%s <server_port>\n", argv[0]);
		return 1;
	}
	int local_port = atoi(argv[1]);

	// Fork new process to constantly ping the network
	int pid = fork();
	if(pid == -1) {
		perror("fork");
		return 1;
	}
	else if(pid == 0) { // Child
		pinger(local_port);
		return 0;
	}

	// Make a socket
	int server_fd;
    if ((server_fd = socket(AF_INET, SOCK_DGRAM, 0)) == 0) {
        perror("socket");
        return 1;
    }
	int opt = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(int))) {
        perror("setsockopt");
        return 1;
    }

	// Setup and bind to port argv[1]
	struct sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(local_port);

    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind");
        return 1;
    }
	printf("Socket up and running on port %s!\n", argv[1]);

	//////////// RPCgen code below ////////////

	register SVCXPRT *transp;

	pmap_unset (SERVER_NODE_PROG, SERVER_NODE_VERSION);

	transp = svcudp_create(server_fd);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, SERVER_NODE_PROG, SERVER_NODE_VERSION, server_node_prog_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (SERVER_NODE_PROG, SERVER_NODE_VERSION, udp).");
		exit(1);
	}

	// TCP RPC communication, commented out since not using
	// transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	// if (transp == NULL) {
	// 	fprintf (stderr, "%s", "cannot create tcp service.");
	// 	exit(1);
	// }
	// if (!svc_register(transp, SERVER_NODE_PROG, SERVER_NODE_VERSION, server_node_prog_1, IPPROTO_TCP)) {
	// 	fprintf (stderr, "%s", "unable to register (SERVER_NODE_PROG, SERVER_NODE_VERSION, tcp).");
	// 	exit(1);
	// }

	svc_run ();
	fprintf (stderr, "%s", "svc_run returned");
	exit (1);
	/* NOTREACHED */
}
